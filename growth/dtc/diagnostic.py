"""Generate instant diagnostic reports for value delivery."""

from datetime import datetime
from typing import List
from pathlib import Path

from jinja2 import Template
from loguru import logger

from models import Lead, ShopifyStore, MetaAdData
from signals import NegativeSignal, format_signal_for_outreach


class DiagnosticReport:
    """Generate diagnostic report for instant value delivery."""

    def __init__(self, output_dir: str = "data/reports"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)

    def generate_report(
        self,
        lead: Lead,
        signals: List[NegativeSignal]
    ) -> str:
        """Generate markdown diagnostic report."""

        if not signals:
            logger.warning(f"No signals to report for {lead.domain}")
            return ""

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{lead.domain.replace('.', '_')}_{timestamp}.md"
        filepath = self.output_dir / filename

        # Calculate total potential savings
        total_loss = sum(s.estimated_loss for s in signals)
        monthly_savings = total_loss * 30

        # Build report
        report = self._build_report_template(lead, signals, total_loss, monthly_savings)

        # Save report
        with open(filepath, 'w') as f:
            f.write(report)

        logger.success(f"Generated diagnostic report: {filepath}")
        return str(filepath)

    def _build_report_template(
        self,
        lead: Lead,
        signals: List[NegativeSignal],
        daily_loss: float,
        monthly_savings: float
    ) -> str:
        """Build markdown report."""

        store = lead.store or ShopifyStore(domain=lead.domain)
        meta = lead.meta_ads or MetaAdData(domain=lead.domain)

        report = f"""# ðŸ“Š Growth Diagnostic Report

**For:** {lead.domain}
**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}
**Report ID:** {datetime.now().strftime('%Y%m%d%H%M%S')}

---

## ðŸ’° Quick Summary

| Metric | Value |
|--------|-------|
| Daily Leaked Revenue | ${daily_loss:,.0f} |
| Monthly Recovery Potential | ${monthly_savings:,.0f} |
| Issues Found | {len(signals)} |
| Urgency Level | {signals[0].severity.upper() if signals else 'LOW'} |

---

## ðŸš¨ Critical Issues Detected

"""

        # Add each signal
        for i, signal in enumerate(signals, 1):
            emoji = "ðŸš¨" if signal.severity == "critical" else "âš ï¸" if signal.severity == "high" else "ðŸ’¡"

            report += f"""
### {i}. {signal.signal_type.replace('_', ' ').title()}

**Severity:** {signal.severity.upper()}

**Problem:**
{signal.description}

**Evidence:**
"""
            # Format evidence as bullet points
            for key, value in signal.evidence.items():
                if value is not None:
                    report += f"- `{key}`: {value}\n"

            report += f"""
**Estimated Impact:** ${signal.estimated_loss:,.0f}/day

**Fix:**
{signal.recommendation}

---

"""

        # Add recommendations section
        report += """
## ðŸ”§ Recommended Actions (Priority Order)

1. **This Week** - Fix critical issues
2. **This Month** - Address high-severity items
3. **Next Quarter** - Build prevention systems

---

## ðŸ“ˆ Current Metrics

| Store Metrics | Value |
|---------------|-------|
| Product Count | """ + str(store.product_count) + f""" |
| Launch Velocity (7d) | {store.launch_velocity_7d} new products |
| Launch Velocity (30d) | {store.launch_velocity_30d} new products |
| Avg Price Point | ${store.avg_price:.2f} |

| Ad Performance | Value |
|----------------|-------|
| Active Ads | {meta.ad_count} |
| Ads Running | """ + ("Yes" if meta.active_ads else "No") + f""" |

---

## ðŸ“ Methodology

This report was generated by analyzing:
- Public product catalog ({store.product_count} SKUs)
- Product launch velocity (last 7/30 days)
- Meta ad library activity
- Pricing and catalog depth patterns

**Note:** All estimates are conservative. Actual savings may vary.

---

*Generated by automated growth diagnostic system*
*Questions? Reply to this message.*

"""

        return report

    def generate_twitter_thread(
        self,
        lead: Lead,
        signals: List[NegativeSignal]
    ) -> List[str]:
        """Generate Twitter thread for public proofing."""

        if not signals:
            return []

        store = lead.store
        meta = lead.meta_ads

        total_loss = sum(s.estimated_loss for s in signals)

        thread = []

        # Tweet 1: Hook
        hook = f"""Just audited a DTC brand spending on ads but bleeding ${total_loss:.0f}/day.

{store.product_count if store else 0} products. {meta.ad_count if meta else 0} active ads.

Here's what they're doing wrong ðŸ§µ"""

        thread.append(hook)

        # Tweets for each signal
        for signal in signals[:3]:  # Max 3 signals
            tweet = f"""{signal.signal_type.replace('_', ' ').title()}:

{signal.description}

Leaking ~${signal.estimated_loss:.0f}/day ðŸ’¸

Fix: {signal.recommendation}"""

            thread.append(tweet)

        # Final tweet: CTA
        cta = f"""If you're @{lead.domain.replace('.myshopify.com', '')} and want the full 20-page diagnostic, reply "AUDIT" and I'll DM it to you.

Free. No catch. Just fix the bleeding. ðŸ©¹"""

        thread.append(cta)

        return thread
