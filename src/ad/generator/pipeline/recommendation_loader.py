"""
Recommendation Loader: Load Visual Recommendation from Creative Scorer Repository.

Loads the visual_recommendation.json generated by the scorer's
recommendation_generator.py module.

Note:
    This loader is for the creative scorer offline repository JSON format.
    For ad/recommender markdown format (primary), use the ad_recommender_adapter
    which handles the conversion from MD to visual formula format.

Path formats:
    - Scorer repo: devease-creative-scorer-offline/data/headroom_analysis/visual_recommendation.json
    - Ad/recommender (primary): config/ad/recommender/{customer}/{platform}/{date}/recommendations.md

Key improvements:
- Filters out low-penetration outliers using configurable thresholds
- Resolves contradictions: Entrance features always win over Headroom
- Data-driven anomaly detection (no hardcoded counter-intuitive lists)
"""

from __future__ import annotations

import json
import logging
from pathlib import Path
from typing import Any, Dict, Optional


# Feature matching thresholds (previously from feature_matcher module)
# Scoring is handled in creative-scorer repo
DEFAULT_MIN_PENETRATION_PCT = 5.0
DEFAULT_MIN_SAMPLE_COUNT = 3
DEFAULT_SUSPICIOUS_ROAS_LIFT_PCT = 50.0


logger = logging.getLogger(__name__)


def _default_scorer_repo_path() -> Path:
    """Default scorer repo location relative to creative-gen repo."""
    return (
        Path(__file__).resolve().parents[4] / "devease-creative-scorer-offline"
    )


def _default_recommendation_path(scorer_repo: Path) -> Path:
    """Default path to visual recommendation JSON."""
    return (
        scorer_repo
        / "data"
        / "headroom_analysis"
        / "visual_recommendation.json"
    )


class RecommendationLoader:
    """
    Load and validate recommendations from the scorer repository.

    The recommendation contains:
    - entrance_features: High-performance baseline features (must include)
    - headroom_features: High ROAS, low penetration features (prioritize)
    - synergy_pairs: Golden formula combinations (1+1>2)
    - negative_guidance: Efficiency traps to avoid
    - generation_instructions: Structured instructions for generation
    """

    def __init__(
        self,
        scorer_repo_path: Optional[Path] = None,
        recommendation_path: Optional[Path] = None,
    ):
        """
        Initialize RecommendationLoader.

        Args:
            scorer_repo_path: Path to scorer repository (default: auto-detect)
            recommendation_path: Direct path to recommendation JSON
                (overrides scorer_repo_path)
        """
        self.scorer_repo_path = (
            Path(scorer_repo_path)
            if scorer_repo_path
            else _default_scorer_repo_path()
        )
        self._recommendation_path = (
            Path(recommendation_path) if recommendation_path else None
        )

    @property
    def recommendation_path(self) -> Path:
        """Get the path to the recommendation JSON."""
        if self._recommendation_path:
            return self._recommendation_path
        return _default_recommendation_path(self.scorer_repo_path)

    def load(
        self,
        filter_outliers: bool = True,
        resolve_contradictions: bool = True,
        min_penetration_pct: Optional[float] = None,
    ) -> Dict[str, Any]:
        """
        Load recommendation from JSON file with quality filtering.

        Args:
            filter_outliers: Remove features with low penetration
            resolve_contradictions: Ensure Entrance wins over Headroom conflicts
            min_penetration_pct: Minimum penetration % to include feature

        Returns:
            Dict containing the cleaned recommendation

        Raises:
            FileNotFoundError: If formula file doesn't exist
            ValueError: If formula is invalid or empty
        """
        path = self.recommendation_path

        if not path.exists():
            raise FileNotFoundError(
                f"Visual recommendation not found: {path}\n"
                f"Run recommendation_generator.py in scorer repo to generate it."
            )

        with open(path, "r", encoding="utf-8") as f:
            recommendation = json.load(f)
        # Validate required fields
        self._validate_recommendation(recommendation)

        original_headroom = len(recommendation.get("headroom_features", []))
        # Use default thresholds (scoring handled in creative-scorer repo)
        if min_penetration_pct is None:
            min_penetration_pct = DEFAULT_MIN_PENETRATION_PCT

        min_sample_count = DEFAULT_MIN_SAMPLE_COUNT
        # Apply quality filters
        if filter_outliers:
            recommendation = self._filter_low_penetration(
                recommendation, min_penetration_pct, int(min_sample_count)
            )

        if resolve_contradictions:
            recommendation = self._resolve_entrance_headroom_conflicts(
                recommendation
            )
        # Flag statistically suspicious features (data-driven, not hardcoded)
        self._flag_suspicious_features(recommendation)

        filtered_headroom = len(recommendation.get("headroom_features", []))

        logger.info(
            "Loaded recommendation: %d entrance, %d headroom "
            "(filtered from %d), %d synergy pairs",
            len(recommendation.get("entrance_features", [])),
            filtered_headroom,
            original_headroom,
            len(recommendation.get("synergy_pairs", [])),
        )

        return recommendation

    def _filter_low_penetration(
        self,
        recommendation: Dict[str, Any],
        min_pct: float,
        min_samples: int = 3,
    ) -> Dict[str, Any]:
        """
        Filter out headroom features with low statistical confidence.

        Features are filtered if:
        - Penetration below threshold (likely outliers)
        - Sample count below minimum (insufficient data)
        """
        headroom = recommendation.get("headroom_features", [])
        filtered = []
        removed = []

        for feat in headroom:
            penetration = feat.get("penetration_pct", 0)
            # Estimate sample count from penetration and total images
            # If not available, use penetration as proxy
            sample_count = feat.get("sample_count", penetration)

            if penetration >= min_pct and sample_count >= min_samples:
                filtered.append(feat)
            else:
                reason = []
                if penetration < min_pct:
                    reason.append(f"pen={penetration:.1f}%")
                if sample_count < min_samples:
                    reason.append(f"n={sample_count}")
                removed.append(
                    f"{feat['feature_name']}={feat['feature_value']} "
                    f"({', '.join(reason)})"
                )

        if removed:
            logger.info(
                "Filtered %d low-penetration headroom features: %s",
                len(removed),
                ", ".join(removed[:5]) + ("..." if len(removed) > 5 else ""),
            )

        recommendation["headroom_features"] = filtered
        return recommendation

    def _resolve_entrance_headroom_conflicts(
        self, recommendation: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Resolve contradictions between Entrance and Headroom features.

        Rule: Entrance features ALWAYS win. If Headroom has a different value
        for the same feature, remove it from Headroom.
        """
        entrance = recommendation.get("entrance_features", [])
        headroom = recommendation.get("headroom_features", [])
        # Build entrance feature map: feature_name -> value
        entrance_values: Dict[str, str] = {}
        for feat in entrance:
            name = feat.get("feature_name", "")
            value = feat.get("feature_value", "")
            entrance_values[name] = value
        # Filter headroom to remove conflicts
        resolved = []
        conflicts = []

        for feat in headroom:
            name = feat.get("feature_name", "")
            value = feat.get("feature_value", "")

            if name in entrance_values:
                entrance_val = entrance_values[name]
                if value != entrance_val:
                    # Conflict! Entrance wins
                    conflicts.append(
                        f"{name}: headroom='{value}' vs "
                        f"entrance='{entrance_val}'"
                    )
                    continue  # Skip this headroom feature

            resolved.append(feat)

        if conflicts:
            logger.warning(
                "Resolved %d Entrance/Headroom conflicts (Entrance wins): %s",
                len(conflicts),
                "; ".join(conflicts[:3])
                + ("..." if len(conflicts) > 3 else ""),
            )

        recommendation["headroom_features"] = resolved
        return recommendation

    def _flag_suspicious_features(self, formula: Dict[str, Any]) -> None:
        """
        Flag statistically suspicious features using data-driven detection.

        A feature is suspicious if:
        - Very high ROAS lift (> threshold) with low penetration
        - This suggests it may be an outlier from small sample size

        This replaces hardcoded counter-intuitive lists with
        statistical detection.
        """
        suspicious_lift_threshold = DEFAULT_SUSPICIOUS_ROAS_LIFT_PCT
        min_pen = DEFAULT_MIN_PENETRATION_PCT

        flagged = []

        for feat in formula.get("headroom_features", []):
            roas_lift = feat.get("roas_lift_pct", 0)
            penetration = feat.get("penetration_pct", 100)
            # Flag if high lift but borderline penetration
            # (between min and 2x min)
            is_borderline_penetration = min_pen <= penetration < min_pen * 2
            is_high_lift = roas_lift > suspicious_lift_threshold

            if is_borderline_penetration and is_high_lift:
                feat["_flagged_suspicious"] = True
                feat["_suspicious_reason"] = (
                    f"High ROAS lift ({roas_lift:.1f}%) with borderline "
                    f"penetration ({penetration:.1f}%)"
                )
                flagged.append(
                    f"{feat['feature_name']}={feat['feature_value']} "
                    f"(lift={roas_lift:.1f}%, pen={penetration:.1f}%)"
                )

        if flagged:
            logger.warning(
                "[WARN] Statistically suspicious features "
                "(review recommended): %s",
                ", ".join(flagged[:5]) + ("..." if len(flagged) > 5 else ""),
            )

    def _validate_recommendation(self, recommendation: Dict[str, Any]) -> None:
        """
        Validate formula structure.

        Raises:
            ValueError: If formula is invalid
        """
        if not recommendation:
            raise ValueError("Creative blueprint is empty")

        required_fields = [
            "account_avg_roas",
            "winning_threshold_roas",
        ]

        for field in required_fields:
            if field not in recommendation:
                raise ValueError(f"Missing required field: {field}")
        # Warn if no features found
        total_features = (
            len(recommendation.get("entrance_features", []))
            + len(recommendation.get("headroom_features", []))
            + len(recommendation.get("synergy_pairs", []))
        )

        if total_features == 0:
            logger.warning(
                "Creative blueprint has no features - generation may be suboptimal"
            )

    def get_generation_instructions(self) -> Dict[str, Any]:
        """
        Get generation instructions from formula.

        Returns:
            Dict with must_include, prioritize, synergy_combinations, avoid
        """
        recommendation = self.load()
        return recommendation.get("generation_instructions", {})

    def get_feature_summary(self) -> Dict[str, Any]:
        """
        Get summary of features in recommendation.

        Returns:
            Dict with counts and key features
        """
        recommendation = self.load()

        entrance = recommendation.get("entrance_features", [])
        headroom = recommendation.get("headroom_features", [])
        synergy = recommendation.get("synergy_pairs", [])
        negative = recommendation.get("negative_guidance", [])

        return {
            "entrance_count": len(entrance),
            "headroom_count": len(headroom),
            "synergy_count": len(synergy),
            "negative_count": len(negative),
            "top_entrance_features": [
                f.get("feature_name") for f in entrance[:5]
            ],
            "top_headroom_features": [
                f.get("feature_name") for f in headroom[:5]
            ],
            "account_avg_roas": recommendation.get("account_avg_roas"),
            "winning_threshold_roas": recommendation.get(
                "winning_threshold_roas"
            ),
            "expected_roas_improvement_pct": recommendation.get(
                "expected_roas_improvement_pct", 0
            ),
        }


def load_visual_recommendation(
    path: Optional[Path] = None,
    scorer_repo_path: Optional[Path] = None,
) -> Dict[str, Any]:
    """
    Convenience function to load recommendation.

    Args:
        path: Direct path to recommendation JSON
        scorer_repo_path: Path to scorer repository

    Returns:
        Creative blueprint dict
    """
    loader = RecommendationLoader(
        scorer_repo_path=scorer_repo_path,
        recommendation_path=path,
    )
    return loader.load()
